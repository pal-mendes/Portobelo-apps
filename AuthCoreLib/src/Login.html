
<!-- Login.html (AuthCoreLib) -->
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      http-equiv="Cache-Control"
      content="no-store, no-cache, must-revalidate, max-age=0"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Área reservada</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        padding: 2em;
      }
      .btn {
        display: inline-block;
        padding: 0.6em 1em;
        border: 1px solid #999;
        border-radius: 6px;
        text-decoration: none;
      }
      #status {
        margin: 0.75em 0 0;
        color: #555;
      }
    </style>

	  <!-- Logger global único (consola apenas) - no head dos html e servido pela AuthCoreLib. Aponta para a implementação B pois tem de ser web App -->
    <script src="https://script.google.com/macros/s/AKfycbw7CwrEid8YLInikNcmpqz9l9GzGFU40zTLL5mrTokCHiSgXivy4WQK6TbekB18tQ59/exec"></script>

    <script>
    /* PB Server Vars — 1.º <script> no <head> (sem efeitos colaterais) */
    (function () {
      // Defensivo: usar typeof para evitar ReferenceError no template
      var SV = { //usar como __SERVER_VARS. no código
        canonUrl:   "<?= (typeof CANON_URL  !== 'undefined' ? CANON_URL  : '') ?>",
        ticket:     "<?= (typeof TICKET     !== 'undefined' ? TICKET     : (typeof ticket !== 'undefined' ? ticket : '')) ?>",
        autostart:  "<?= (typeof AUTOSTART  !== 'undefined' ? AUTOSTART  : '') ?>",   // '1' | ''
        debugServer:"<?= (typeof DEBUG      !== 'undefined' ? DEBUG      : '') ?>" === "1",
        serverLog:  `<?= (typeof SERVER_LOG !== 'undefined' ? SERVER_LOG : '') ?>`,
        wipe:       "<?= (typeof WIPE       !== 'undefined' ? WIPE       : '') ?>",   // '1' | ''
        pageTag:    "<?= (typeof PAGE_TAG   !== 'undefined' ? PAGE_TAG   : '') ?>" // etiqueta para prefixo nos logs ex.: 'LOGIN' | 'RGPD' | 'MAIN'
      };

      // Flags calculadas no cliente
      SV.noRedirect = /[?&]noredirect=1\b/i.test(location.search);

      const CANON_SELF = location.origin + location.pathname;

      SV.canonSelf = CANON_SELF;
      window.CANON_SELF = CANON_SELF;

      // Persistir: self (embed) e canon (/exec) se existir
      try { localStorage.setItem("appSelfUrl", CANON_SELF); } catch(_) {}
      try { if ((SV.canonUrl || "").trim()) localStorage.setItem("appCanonicalUrl", SV.canonUrl.trim()); } catch(_) {}

      // Expor de forma limpa
      window.__SERVER_VARS = Object.freeze(SV);

      // Ponte mínima (se quiser eliminar depois, pode)
      window.CANON_URL      = SV.canonUrl;
      window.SESSION_TICKET = SV.ticket;
      window.SERVER_LOG     = SV.serverLog;

      // --- Stubs anti-erro: garantem que log/dbg existem MESMO antes do logger carregar
      window.log = window.log || function(){ try{ console.log.apply(console, arguments); }catch(_){} };
      window.dbg = window.dbg || function(){};
  })();
  </script>

  </head>

  <body>
    <h2>Área reservada a associados</h2>
    <p>
      <a id="login-link" class="btn" href="#" style="display: none"
        >Entrar com conta Google</a
      >
    </p>
    <div id="status"></div>

    <!-- 1) Optional wipe (quando renderizado com WIPE=1) -->
    <script>
      (function () {
        const WIPE = (__SERVER_VARS.wipe === '1');
        if (!WIPE) return;
        try {
          localStorage.removeItem("sessTicket");
          log("Login.html wipe: localStorage ok");
        } catch (e) {
          log("Login.html wipe ls ERR " + e);
        }
        try {
          document.cookie =
            "sessTicket=; Max-Age=0; Path=/; Secure; SameSite=Lax";
          log("Login.html wipe: cookie ok");
        } catch (e) {
          log("Login.html wipe cookie ERR " + e);
        }
      })();
    </script>

    <!-- 2) Fluxo de autenticação -->
    <script>
      (function () {
        log("Login.html fluxo de autenticação");
        const BTN = document.getElementById("login-link");
        const ST = document.getElementById("status");

        const WANT_DEBUG = window.DEBUG;
        const CANON_URL  = (__SERVER_VARS.canonUrl || (function(){ try{return localStorage.getItem('appCanonicalUrl')}catch(_){return ''} })() || (location.origin + location.pathname));

        const UI_DELAY_BTN = 1200; // só mostramos o botão passado isto (auto)
        const UI_DELAY_HINT = 2500; // só mostramos um hint/fallback passado isto (auto)
        const GIVE_UP = 10000; // depois disto mostramos tudo

        function setStatus(s, asHTML) {
          if (!ST) return;
          if (asHTML) ST.innerHTML = s;
          else ST.textContent = s;
        }

        function canonExec() {
          const sv = window.__SERVER_VARS || {};
          // prioridade: o CANON do servidor (…/exec). Fallback: o que houver.
          return (
            (sv.canonUrl || sv.CANON_URL || window.CANON_URL || window.CANON || "").trim() ||
            (location.origin + location.pathname)
          );
        }

        function persistTicket(t) {
          try { localStorage.setItem("sessTicket", t); } catch (e) {}
          try {
            document.cookie =
              "sessTicket=" + encodeURIComponent(t) +
              "; Path=/; Max-Age=2592000; SameSite=Lax; Secure";
          } catch (e) {}
        }

        function bestLocalTicket() {
          try {
            const t = localStorage.getItem("sessTicket") || "";
            if (t) return t;
          } catch (_) {}
          try {
            const m = (document.cookie || "").match(
              /(?:^|;\s*)sessTicket=([^;]+)/,
            );
            return m && m[1] ? decodeURIComponent(m[1]) : "";
          } catch (_) {}
          return "";
        }

        function goWithTicket(ticket) {
          persistTicket(ticket); // IMPORTANTÍSSIMO: antes de mexer no location
          const u = new URL(canonExec());
          u.searchParams.set("ticket", ticket);

          const qs = new URLSearchParams(location.search);
          if (qs.get("debug") === "1") u.searchParams.set("debug", "1");

          u.searchParams.set("ts", String(Date.now()));
          log("[LOGIN] goWithTicket → " + u.toString());
          // em Sites: navegar SEMPRE o próprio iframe
          location.replace(u.toString());
        }

        // Receber ticket via postMessage
        let popupRef = null;
        window.addEventListener("message", function (ev) {
          const d = (ev && ev.data) || {};
          if (d && d.type === "portobelo_ticket" && d.ticket) {
            log("Login.html ticket via postMessage");
            try {
              if (popupRef && !popupRef.closed) popupRef.close();
            } catch (_) {}
            goWithTicket(d.ticket);
          }
        });

        // Polling de fallback (3 min)
        function startServerPolling(nonce, authUrl) {
          log("Login.html startServerPolling(" + nonce + ")");
          const t0 = Date.now();
          const MAX = 180000;
          let delay = 1800;
          let done = false;

          // UI atrasada (hint) só se nada acontecer
          log("Login.html#176 hintTimer=setTimeout()");
          const hintTimer = setTimeout(function () {
            if (!done)
              setStatus(
                'A autenticação abriu numa nova janela. Se não avançar, <a href="' +
                  authUrl +
                  '" target="_top" rel="noopener">clique aqui</a>.',
                true,
              );
          }, UI_DELAY_HINT);

          (function tick() {
            if (done) return;
            google.script.run
              .withSuccessHandler(function (ticket) {
                if (done) return;
                if (ticket) {
                  done = true;
                  clearTimeout(hintTimer);
                  log("Login.html server → ticket (" + String(ticket).slice(0, 12) + "…)");
                  try {
                    if (popupRef && !popupRef.closed) popupRef.close();
                  } catch (_) {}
                  goWithTicket(ticket);
                  return;
                }
                if (Date.now() - t0 > MAX) {
                  done = true;
                  setStatus("Tempo esgotado.");
                  return;
                }
                delay = Math.min(delay * 1.35, 6500);
                log("Login.html#208 pollTicket success setTimeout()");
                setTimeout(tick, delay + Math.random() * 250);
              })
              .withFailureHandler(function () {
                if (done) return;
                if (Date.now() - t0 > MAX) {
                  done = true;
                  setStatus("Tempo esgotado.");
                  return;
                }
                delay = Math.min(delay * 1.35, 6500);
                log("Login.html#219 pollTicket failure setTimeout()");
                setTimeout(tick, delay);
              })
              .pollTicket(nonce);
          })();
        }

        function beginAuthFlow(manualClick) {
          log("Login.html beginAuthFlow");
          const nonce =
            crypto && crypto.randomUUID
              ? crypto.randomUUID()
              : Date.now() + "." + Math.random();
          setStatus("A preparar autenticação…");

          google.script.run
            .withSuccessHandler(function (authUrl) {
              // Tentativa 1: POPUP
              try {
                popupRef = window.open(
                  authUrl,
                  "portobeloAuth",
                  "width=520,height=720",
                );
              } catch (_) {
                popupRef = null;
              }

              if (!popupRef) {
                // Se popup bloqueada:
                log("Login.html popup blocked");
                if (manualClick) {
                  // se foi clique do utilizador, mostra já alternativas
                  setStatus(
                    'Pop-up bloqueado. <a href="' +
                      authUrl +
                      '" target="_top" rel="noopener">Clique aqui para continuar</a>.',
                    true,
                  );
                  if (BTN) BTN.style.display = "";
                } else {
                  // se foi auto: só mostramos UI após pequenos atrasos
                  log("Login.html#261 buildAuthUrlFor popup OK setTimeout()");
                  setTimeout(function () {
                    if (BTN) BTN.style.display = "";
                  }, UI_DELAY_BTN);
                  setTimeout(function () {
                    setStatus(
                      'Não foi possível abrir a janela automaticamente. <a href="' +
                        authUrl +
                        '" target="_top" rel="noopener">Clique aqui para continuar</a>.',
                      true,
                    );
                  }, UI_DELAY_HINT);
                  setTimeout(function () {
                    if (BTN) BTN.style.display = "";
                  }, GIVE_UP);
                }
                return;
              }

              // Popup OK
              log("Login.html popup opened OK");
              setStatus(
                "A autenticação abriu numa nova janela. Conclua o login nessa janela.",
              );
              startServerPolling(nonce, authUrl);
            })
            .withFailureHandler(function (err) {
              log(
                "Login.html buildAuthUrlFor fail: " +
                  (err && err.message ? err.message : err),
              );
              setStatus(
                "Não foi possível iniciar a autenticação. Tente novamente.",
              );
              if (BTN) BTN.style.display = "";
            })
            .buildAuthUrlFor(nonce, WANT_DEBUG, window.top !== window);
        }

        // Botão (para quando a pop-up automática falha ou NOREDIRECT)
        BTN.addEventListener("click", function (ev) {
          ev.preventDefault();
          beginAuthFlow(true);
        });

        // Bootstrap “seguro”: se já houver ticket local/cookie válido, vai direto
        (function bootstrap() {
          log("Login.html function bootstrap…");
          if (__SERVER_VARS.noRedirect) {
            if (BTN) BTN.style.display = "";
            return;
          }

          const t = bestLocalTicket();
          if (!t) {
            // sem ticket → podemos autostartar popup (se AUTOSTART=1)
            const AUTOSTART = __SERVER_VARS.autostart;
            if (AUTOSTART) {
              // não mostra nada já: tenta popup; só mostra UI se falhar/atrasar
              beginAuthFlow(false);
              // proteção: ao fim de X segundos, garante que pelo menos o botão aparece
              log("Login.html#318 setTimeout()");
              setTimeout(function () {
                if (BTN) BTN.style.display = "";
              }, GIVE_UP);
            } else {
              if (BTN) BTN.style.display = "";
            }
            return;
          }

          log("Login.html bootstrap Found local/cookie ticket — validating…");
          google.script.run
            .withSuccessHandler(function (valid) {
              if (valid) {
                goWithTicket(t);
                return;
              }
              log("Login.html ticket inválido → wipe");
              try {
                localStorage.removeItem("sessTicket");
              } catch (_) {}
              try {
                document.cookie =
                  "sessTicket=; Max-Age=0; Path=/; Secure; SameSite=Lax";
              } catch (_) {}
              setStatus(
                'A sua sessão expirou. Clique em "Entrar com conta Google".',
              );
              if (BTN) BTN.style.display = "";
            })
            .withFailureHandler(function (err) {
              log("Login.html validate fail: " + (err && err.message ? err.message : err));
              setStatus(
                'Não foi possível validar a sessão. Clique em "Entrar com conta Google".',
              );
              if (BTN) BTN.style.display = "";
            })
            .isTicketValid(t);
        })();
      })();
    </script>
  </body>
</html>
