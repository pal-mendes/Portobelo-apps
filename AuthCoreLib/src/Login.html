
<!-- Login.html (AuthCoreLib) -->
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      http-equiv="Cache-Control"
      content="no-store, no-cache, must-revalidate, max-age=0"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Área reservada</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        padding: 2em;
      }
      .btn {
        display: inline-block;
        padding: 0.6em 1em;
        border: 1px solid #999;
        border-radius: 6px;
        text-decoration: none;
      }
      #status {
        margin: 0.75em 0 0;
        color: #555;
      }
    </style>

	  <!-- Logger global único (consola apenas) - no head dos html e servido pela AuthCoreLib. Aponta para a implementação B pois tem de ser web App -->
    <script src="https://script.google.com/macros/s/AKfycbw7CwrEid8YLInikNcmpqz9l9GzGFU40zTLL5mrTokCHiSgXivy4WQK6TbekB18tQ59/exec"></script>

    <script>
    /* PB Server Vars — 1.º <script> no <head> (sem efeitos colaterais) */
    (function () {
      // Defensivo: usar typeof para evitar ReferenceError no template
      var SV = { //usar como __SERVER_VARS. no código
        canonUrl:   "<?= (typeof CANON_URL  !== 'undefined' ? CANON_URL  : '') ?>",
        ticket:     "<?= (typeof TICKET     !== 'undefined' ? TICKET     : (typeof ticket !== 'undefined' ? ticket : '')) ?>",
        autostart:  "<?= (typeof AUTOSTART  !== 'undefined' ? AUTOSTART  : '') ?>",   // '1' | ''
        debugServer:"<?= (typeof DEBUG      !== 'undefined' ? DEBUG      : '') ?>" === "1",
        serverLog:  `<?= (typeof SERVER_LOG !== 'undefined' ? SERVER_LOG : '') ?>`,
        wipe:       "<?= (typeof WIPE       !== 'undefined' ? WIPE       : '') ?>",   // '1' | ''
        pageTag:    "<?= (typeof PAGE_TAG   !== 'undefined' ? PAGE_TAG   : '') ?>" // etiqueta para prefixo nos logs ex.: 'LOGIN' | 'RGPD' | 'MAIN'
      };

      // Flags calculadas no cliente
      SV.noRedirect = /[?&]noredirect=1\b/i.test(location.search);

      const CANON_SELF = location.origin + location.pathname;

      SV.canonSelf = CANON_SELF;
      window.CANON_SELF = CANON_SELF;

      // Persistir: self (embed) e canon (/exec) se existir
      try { localStorage.setItem("appSelfUrl", CANON_SELF); } catch(_) {}
      try { if ((SV.canonUrl || "").trim()) localStorage.setItem("appCanonicalUrl", SV.canonUrl.trim()); } catch(_) {}

      // Expor de forma limpa
      window.__SERVER_VARS = Object.freeze(SV);

      // Ponte mínima (se quiser eliminar depois, pode)
      window.CANON_URL      = SV.canonUrl;
      window.SESSION_TICKET = SV.ticket;
      window.SERVER_LOG     = SV.serverLog;

      // --- Stubs anti-erro: garantem que log/dbg existem MESMO antes do logger carregar
      window.log = window.log || function(){ try{ console.log.apply(console, arguments); }catch(_){} };
      window.dbg = window.dbg || function(){};
  })();
  </script>

  </head>

  <body>
    <h2>Área reservada a associados</h2>
    <p>
      <a id="login-link" class="btn" href="#" style="display: none"
        >Entrar com conta Google</a
      >
    </p>
    <div id="status"></div>

    <!-- 1) Optional wipe (quando renderizado com WIPE=1) -->
    <script>
      (function () {
        const WIPE = (__SERVER_VARS.wipe === '1');
        if (!WIPE) return;
        try {
          localStorage.removeItem("sessTicket");
          log("wipe: localStorage ok");
        } catch (e) {
          log("wipe ls ERR " + e);
        }
        try {
          document.cookie =
            "sessTicket=; Max-Age=0; Path=/; Secure; SameSite=Lax";
          log("wipe: cookie ok");
        } catch (e) {
          log("wipe cookie ERR " + e);
        }
      })();
    </script>

    <!-- 2) Fluxo de autenticação -->
    <script>
      (function () {
        log("Login.html fluxo de autenticação");
        const BTN = document.getElementById("login-link");
        const ST = document.getElementById("status");

        const WANT_DEBUG = window.DEBUG;
        const CANON_URL  = (__SERVER_VARS.canonUrl || (function(){ try{return localStorage.getItem('appCanonicalUrl')}catch(_){return ''} })() || (location.origin + location.pathname));

        const UI_DELAY_BTN = 1200; // só mostramos o botão passado isto (auto)
        const UI_DELAY_HINT = 2500; // só mostramos um hint/fallback passado isto (auto)
        const GIVE_UP = 10000; // depois disto mostramos tudo

        function setStatus(s, asHTML) {
          if (!ST) return;
          if (asHTML) ST.innerHTML = s;
          else ST.textContent = s;
        }
        function bestLocalTicket() {
          try {
            const t = localStorage.getItem("sessTicket") || "";
            if (t) return t;
          } catch (_) {}
          try {
            const m = (document.cookie || "").match(
              /(?:^|;\s*)sessTicket=([^;]+)/,
            );
            return m && m[1] ? decodeURIComponent(m[1]) : "";
          } catch (_) {}
          return "";
        }
        function goWithTicket(t) {
          const base =
            window.CANON_SELF ||
            (window.__SERVER_VARS && window.__SERVER_VARS.canonSelf) ||
            (location.origin + location.pathname);

          const next =
            base +
            "?ticket=" +
            encodeURIComponent(t) +
            (WANT_DEBUG ? "&debug=1" : "") +
            "&ts=" +
            Date.now(); // evita cache estranha

          log("Login.html goWithTicket → " + next);
          try { localStorage.setItem("sessTicket", t); } catch (_) {}
          
          // Mostra SEMPRE um fallback manual que aponta para o NEXT (não para o OAuth!)
          setStatus(
            'A redirecionar... Se não avançar <a href="' + next + '" target="_self" rel="noopener">clique aqui</a>',
            true
          );

          try {
            log("Login.html location.replace " + next);
            location.replace(next);
            return;
          } catch (err) {
            log("same-frame replace failed: " + ((err && err.message) || err));
          }

          // fallback: gesto do utilizador (link)
          try {
            const a = document.createElement("a");
            a.href = next;
            a.target = "_self";
            a.rel = "noopener";
            document.body.appendChild(a);
            a.click();
            a.remove();
          } catch (_) {}
            
        }

        // Receber ticket via postMessage
        let popupRef = null;
        window.addEventListener("message", function (ev) {
          const d = (ev && ev.data) || {};
          if (d && d.type === "portobelo_ticket" && d.ticket) {
            log("ticket via postMessage");
            try {
              if (popupRef && !popupRef.closed) popupRef.close();
            } catch (_) {}
            goWithTicket(d.ticket);
          }
        });

        // Polling de fallback (3 min)
        function startServerPolling(nonce, authUrl) {
          log("startServerPolling(" + nonce + ")");
          const t0 = Date.now();
          const MAX = 180000;
          let delay = 1800;
          let done = false;

          // UI atrasada (hint) só se nada acontecer
          const hintTimer = setTimeout(function () {
            if (!done)
              setStatus(
                'A autenticação abriu numa nova janela. Se não avançar, <a href="' +
                  authUrl +
                  '" target="_top" rel="noopener">clique aqui</a>.',
                true,
              );
          }, UI_DELAY_HINT);

          (function tick() {
            if (done) return;
            google.script.run
              .withSuccessHandler(function (ticket) {
                if (done) return;
                if (ticket) {
                  done = true;
                  clearTimeout(hintTimer);
                  log("server → ticket (" + String(ticket).slice(0, 12) + "…)");
                  try {
                    if (popupRef && !popupRef.closed) popupRef.close();
                  } catch (_) {}
                  goWithTicket(ticket);
                  return;
                }
                if (Date.now() - t0 > MAX) {
                  done = true;
                  setStatus("Tempo esgotado.");
                  return;
                }
                delay = Math.min(delay * 1.35, 6500);
                setTimeout(tick, delay + Math.random() * 250);
              })
              .withFailureHandler(function () {
                if (done) return;
                if (Date.now() - t0 > MAX) {
                  done = true;
                  setStatus("Tempo esgotado.");
                  return;
                }
                delay = Math.min(delay * 1.35, 6500);
                setTimeout(tick, delay);
              })
              .pollTicket(nonce);
          })();
        }

        function beginAuthFlow(manualClick) {
          log("Login.html beginAuthFlow");
          const nonce =
            crypto && crypto.randomUUID
              ? crypto.randomUUID()
              : Date.now() + "." + Math.random();
          setStatus("A preparar autenticação…");

          google.script.run
            .withSuccessHandler(function (authUrl) {
              // Tentativa 1: POPUP
              try {
                popupRef = window.open(
                  authUrl,
                  "portobeloAuth",
                  "width=520,height=720",
                );
              } catch (_) {
                popupRef = null;
              }

              if (!popupRef) {
                // Se popup bloqueada:
                log("popup blocked");
                if (manualClick) {
                  // se foi clique do utilizador, mostra já alternativas
                  setStatus(
                    'Pop-up bloqueado. <a href="' +
                      authUrl +
                      '" target="_top" rel="noopener">Clique aqui para continuar</a>.',
                    true,
                  );
                  if (BTN) BTN.style.display = "";
                } else {
                  // se foi auto: só mostramos UI após pequenos atrasos
                  setTimeout(function () {
                    if (BTN) BTN.style.display = "";
                  }, UI_DELAY_BTN);
                  setTimeout(function () {
                    setStatus(
                      'Não foi possível abrir a janela automaticamente. <a href="' +
                        authUrl +
                        '" target="_top" rel="noopener">Clique aqui para continuar</a>.',
                      true,
                    );
                  }, UI_DELAY_HINT);
                  setTimeout(function () {
                    if (BTN) BTN.style.display = "";
                  }, GIVE_UP);
                }
                return;
              }

              // Popup OK
              log("popup opened OK");
              setStatus(
                "A autenticação abriu numa nova janela. Conclua o login nessa janela.",
              );
              startServerPolling(nonce, authUrl);
            })
            .withFailureHandler(function (err) {
              log(
                "buildAuthUrlFor fail: " +
                  (err && err.message ? err.message : err),
              );
              setStatus(
                "Não foi possível iniciar a autenticação. Tente novamente.",
              );
              if (BTN) BTN.style.display = "";
            })
            .buildAuthUrlFor(nonce, WANT_DEBUG, window.top !== window);
        }

        // Botão (para quando a pop-up automática falha ou NOREDIRECT)
        BTN.addEventListener("click", function (ev) {
          ev.preventDefault();
          beginAuthFlow(true);
        });

        // Bootstrap “seguro”: se já houver ticket local/cookie válido, vai direto
        (function bootstrap() {
          log("Login.html function bootstrap…");
          if (__SERVER_VARS.noRedirect) {
            if (BTN) BTN.style.display = "";
            return;
          }

          const t = bestLocalTicket();
          if (!t) {
            // sem ticket → podemos autostartar popup (se AUTOSTART=1)
            const AUTOSTART = __SERVER_VARS.autostart;
            if (AUTOSTART) {
              // não mostra nada já: tenta popup; só mostra UI se falhar/atrasar
              beginAuthFlow(false);
              // proteção: ao fim de X segundos, garante que pelo menos o botão aparece
              setTimeout(function () {
                if (BTN) BTN.style.display = "";
              }, GIVE_UP);
            } else {
              if (BTN) BTN.style.display = "";
            }
            return;
          }

          log("bootstrap Found local/cookie ticket — validating…");
          google.script.run
            .withSuccessHandler(function (valid) {
              if (valid) {
                goWithTicket(t);
                return;
              }
              log("Ticket inválido → wipe");
              try {
                localStorage.removeItem("sessTicket");
              } catch (_) {}
              try {
                document.cookie =
                  "sessTicket=; Max-Age=0; Path=/; Secure; SameSite=Lax";
              } catch (_) {}
              setStatus(
                'A sua sessão expirou. Clique em "Entrar com conta Google".',
              );
              if (BTN) BTN.style.display = "";
            })
            .withFailureHandler(function (err) {
              log("validate fail: " + (err && err.message ? err.message : err));
              setStatus(
                'Não foi possível validar a sessão. Clique em "Entrar com conta Google".',
              );
              if (BTN) BTN.style.display = "";
            })
            .isTicketValid(t);
        })();
      })();
    </script>
  </body>
</html>
