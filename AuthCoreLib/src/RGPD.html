
<!-- RGPD.html (em AuthCoreLib) -->
<!doctype html>
<html>
  <head>
    <base target="_self" />
    <meta charset="utf-8" />
    <title>RGPD</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        max-width: 820px;
        margin: 18px auto;
        padding: 0 14px;
        line-height: 1.45;
      }
      .card {
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        padding: 14px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      button {
        padding: 8px 12px;
        border: 1px solid #999;
        border-radius: 8px;
        background: #fff;
        cursor: pointer;
      }
    </style>

	  <!-- Logger global único (consola apenas) - no head dos html e servido pela AuthCoreLib. Aponta para a implementação B pois tem de ser web App -->
    <script src="https://script.google.com/macros/s/AKfycbw7CwrEid8YLInikNcmpqz9l9GzGFU40zTLL5mrTokCHiSgXivy4WQK6TbekB18tQ59/exec"></script>

    <script>
    /* PB Server Vars — 1.º <script> no <head> (sem efeitos colaterais) */
    (function () {
      // Defensivo: usar typeof para evitar ReferenceError no template
      var SV = { //usar como __SERVER_VARS. no código
        canonUrl:   "<?= (typeof CANON_URL  !== 'undefined' ? CANON_URL  : '') ?>",
        ticket:     "<?= (typeof TICKET     !== 'undefined' ? TICKET     : (typeof ticket !== 'undefined' ? ticket : '')) ?>",
        autostart:  "<?= (typeof AUTOSTART  !== 'undefined' ? AUTOSTART  : '') ?>",   // '1' | ''
        debugServer:"<?= (typeof DEBUG      !== 'undefined' ? DEBUG      : '') ?>" === "1",
        serverLog:  `<?= (typeof SERVER_LOG !== 'undefined' ? SERVER_LOG : '') ?>`,
        wipe:       "<?= (typeof WIPE       !== 'undefined' ? WIPE       : '') ?>",   // '1' | ''
        pageTag:    "<?= (typeof PAGE_TAG   !== 'undefined' ? PAGE_TAG   : '') ?>" // etiqueta para prefixo nos logs ex.: 'LOGIN' | 'RGPD' | 'MAIN'
      };

      // Flags calculadas no cliente
      SV.noRedirect = /[?&]noredirect=1\b/i.test(location.search);

      const CANON_SELF = location.origin + location.pathname;

      SV.canonSelf = CANON_SELF;
      window.CANON_SELF = CANON_SELF;

      // Persistir: self (embed) e canon (/exec) se existir
      try { localStorage.setItem("appSelfUrl", CANON_SELF); } catch(_) {}
      try { if ((SV.canonUrl || "").trim()) localStorage.setItem("appCanonicalUrl", SV.canonUrl.trim()); } catch(_) {}

      // Expor de forma limpa
      window.__SERVER_VARS = Object.freeze(SV);

      // Ponte mínima (se quiser eliminar depois, pode)
      window.CANON_URL      = SV.canonUrl;
      window.SESSION_TICKET = SV.ticket;
      window.SERVER_LOG     = SV.serverLog;

      // --- Stubs anti-erro: garantem que log/dbg existem MESMO antes do logger carregar
      window.log = window.log || function(){ try{ console.log.apply(console, arguments); }catch(_){} };
      window.dbg = window.dbg || function(){};
  })();
  </script>
    
  </head>
  <body>
    <h2>Proteção de dados (RGPD)</h2>
    <div class="card">
      <p><b>REGULAMENTO DA ASSOCIAÇÃO DOS TITULARES DE DRHP DO PORTOBELO</b></p>
      <p><b>Artigo 9.º — Proteção de dados</b></p>
      <ol>
        <li>
          A Associação recolhe e trata dados pessoais dos associados
          estritamente necessários ao cumprimento dos seus fins, designadamente
          identificação, contactos e dados relativos às semanas detidas.
        </li>
        <li>
          A Associação compromete-se a adotar medidas técnicas e organizativas
          adequadas para a proteção desses dados.
        </li>
        <li>
          Os dados serão usados apenas para fins associativos, com respeito pelo
          RGPD e legislação nacional.
        </li>
        <li>
          Os associados têm direito a aceder, retificar e solicitar a eliminação
          dos seus dados, salvo os que sejam legalmente obrigatórios para o
          funcionamento da Associação.
        </li>
      </ol>
      <div id="rgpd-multi" style="display: none; margin: 12px 0"></div>
      <div id="rgpd-multi-actions" style="display: none; margin: 12px 0">
        <button id="rgpd-save" class="btn">Guardar</button>
      </div>
    </div>

    <script>
      (function () {

        /*
        const EMBED = (function(){
          // estamos dentro de um <iframe> (top !== self) e viemos do teu site/Sites
          if (window.top === window.self) return false;
          const ref = document.referrer || '';
          return /titulares-portobelo\.pt|sites\.google\.com/i.test(ref);
        })();
        */

        log(`RGPD page`);

        function detectEnv(){
          const IN_IFRAME = (function(){ try { return window.top !== window.self; } catch(_) { return true; } })();
          const AO = (location.ancestorOrigins && Array.from(location.ancestorOrigins)) || [];

          // Qualquer origem Apps Script wrapper
          const isAppsScript = (o) => /^(https:\/\/[-\w.]*script\.googleusercontent\.com|https:\/\/script\.google\.com)$/i.test(o);

          // Estamos “externamente embebidos” se houver PELO MENOS um ancestor que NÃO seja Apps Script
          const HAS_NON_APPS_ANCESTOR = AO.some(o => !isAppsScript(o));

          const EXTERNAL_EMBED = IN_IFRAME && HAS_NON_APPS_ANCESTOR;
          //return { IN_IFRAME, EXTERNAL_EMBED, AO };
          return { EXTERNAL_EMBED };
        }

        const WANT_DEBUG  = window.DEBUG;

        // ✅ EMBED robusto
        const { EXTERNAL_EMBED } = detectEnv();
        const EMBED = /\bembed=1\b/i.test(location.search) || EXTERNAL_EMBED;  // só é true em iframe EXTERNO

        let CANON  = (__SERVER_VARS.canonUrl || (function(){ try{return localStorage.getItem('appCanonicalUrl')}catch(_){return ''} })() || (location.origin + location.pathname));
        if (!CANON) {
          try { CANON = localStorage.getItem('appCanonicalUrl') || ''; } catch(_) {}
          if (!CANON) CANON = location.origin + location.pathname;
        }

        let TICKET = (__SERVER_VARS.ticket || (new URL(location.href).searchParams.get('ticket') || (function(){ try{return localStorage.getItem('sessTicket')}catch(_){return ''} })()));
        if (!TICKET) {
          // 1) tenta apanhar do URL (vindo do Main com ?ticket=…)
          try { TICKET = new URL(location.href).searchParams.get('ticket') || ''; } catch(_) {}
        }
        if (!TICKET) {
          // 2) último recurso: localStorage (só funciona se mesma origem)
          try { TICKET = localStorage.getItem('sessTicket') || ''; } catch(_) {}
        }


        log(`RGPD page ready; CANON=${CANON}; have TICKET=${!!TICKET}; EMBED=${EMBED}; EXTERNAL_EMBED=${EXTERNAL_EMBED}`);

        function spanChip(txt){
          return `<span style="display:inline-block;border:1px solid #e5e7eb;border-radius:999px;padding:2px 8px;background:#eef2ff;font-family:ui-monospace,monospace">${String(txt||"").replace(/</g,"&lt;").replace(/>/g,"&gt;")}</span>`;
        }

        function buildSelfUrl_() {
          const u = new URL(location.href);
          ["ticket","action","go","rows","from","ts","wipe"].forEach(k => u.searchParams.delete(k));
          if (!DBG) u.searchParams.delete("debug");
          return u;
        }

        function goWithParams(params) {
          const u = buildSelfUrl_();
          Object.entries(params || {}).forEach(([k, v]) => {
            if (v === null || v === undefined || v === "") u.searchParams.delete(k);
            else u.searchParams.set(k, String(v));
          });
          if (DBG) u.searchParams.set("debug", "1");
          u.searchParams.set("ts", String(Date.now()));
          const where = u.toString();
          dbg("[RGPD] replace → " + where);
          location.replace(where);
        }

        function renderMulti(rows){
          log("[RGPD/multi] entrada");
          try { log("[RGPD/multi] rows=" + JSON.stringify(rows)); } catch(_){}
          if (!rows || !rows.length){
            log("[RGPD/multi] nenhuma linha para este utilizador");
            const box = document.getElementById('rgpd-multi');
            box.style.display = '';
            box.innerHTML = `
              <div class="card">
                <div class="muted">Não há linhas para gerir o RGPD neste e-mail.</div>
                <div style="margin-top:8px">
                  <button id="rgpd-back">Voltar</button>
                </div>
              </div>`;
            document.getElementById('rgpd-back')?.addEventListener('click', () => {
              const BASE = (window.CANON_SELF || CANON_URL);
              const u = new URL(BASE);
              if (TICKET) u.searchParams.set("ticket", TICKET);
              if (WANT_DEBUG)    u.searchParams.set("debug", "1");
              u.searchParams.set("ts", Date.now());
              location.replace(u.toString());
            });
            return;
          }

          log("[RGPD/multi] criar html");
          // constroi cards com checkboxes
          const html = rows.map(r => `
            <div class="card" style="border:1px solid #e5e7eb;border-radius:10px;padding:10px;margin:8px 0">
              <label style="display:flex;gap:10px;align-items:center;cursor:pointer">
                <input type="checkbox" data-row="${r.row}" ${r.rgpd ? "checked":""}>
                <div>
                  <div><b>Semana(s)</b> ${spanChip(r.semanas)}</div>
                  <div class="muted small rgpd-label">RGPD: ${r.rgpd ? "Aceite" : "Rejeitado"}</div>
                </div>
              </label>
            </div>
          `).join("");

          const box = document.getElementById('rgpd-multi');
          box.innerHTML = html;
          box.style.display = '';

          // Atualiza rótulo “RGPD: …” em tempo real
          box.querySelectorAll('input[type="checkbox"][data-row]').forEach(cb => {
            const row = +cb.getAttribute('data-row');
            const lab = cb.closest('.card')?.querySelector('.rgpd-label');
            const update = () => {
              const on = !!cb.checked;
              if (lab) lab.textContent = 'RGPD: ' + (on ? 'Aceite' : 'Rejeitado');
              log(`[RGPD/multi] toggle row=${row} → ${on ? 'Aceite' : 'Rejeitado'}`);
            };
            cb.addEventListener('change', update);
          });

          const actions = document.getElementById('rgpd-multi-actions');
          actions.style.display = '';

          const btn = document.getElementById("rgpd-save");
          if (btn) { btn.disabled = true; btn.textContent = "A gravar…"; }

          google.script.run
            .withSuccessHandler(() => {
              if (btn) btn.textContent = "Guardado ✔";
              // Voltar ao fluxo normal (Main), mantendo o iframe “encaixado”
              goWithParams({ ticket: TICKET, from: "rgpd-save" });
            })
            .withFailureHandler((err) => {
              if (btn) { btn.disabled = false; btn.textContent = "Guardar"; }
              alert("Erro ao gravar RGPD: " + (err && (err.message || err)));
            })
            .setRgpdRowsFor(TICKET, accepted);

        }

        log("about to call listRgpdRowsFor (host)"); //!
        // Chama o host para obter linhas; se vier vazio, a página da biblioteca fica no modo single padrão
        google.script.run
          .withSuccessHandler(renderMulti)
          .withFailureHandler(function(err){
            alert("Erro a carregar linhas: " + (err && err.message ? err.message : String(err)));
          })
          .listRgpdRowsFor(TICKET);
      })();
    </script>
  </body>
</html>
