
<!-- RGPD.html (em AuthCoreLib) -->
<!doctype html>
<html>
  <head>
    <base target="_self" />
    <meta charset="utf-8" />
    <title>RGPD</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        max-width: 820px;
        margin: 18px auto;
        padding: 0 14px;
        line-height: 1.45;
      }
      .card {
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        padding: 14px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      button {
        padding: 8px 12px;
        border: 1px solid #999;
        border-radius: 8px;
        background: #fff;
        cursor: pointer;
      }
    </style>

    <script>
    /* PB Server Vars — 1.º <script> no <head> (sem efeitos colaterais) */
    (function () {
      // Defensivo: usar typeof para evitar ReferenceError no template
      var SV = { //usar como __SERVER_VARS. no código
        canonUrl:   "<?= (typeof CANON_URL  !== 'undefined' ? CANON_URL  : '') ?>",
        ticket:     "<?= (typeof TICKET     !== 'undefined' ? TICKET     : (typeof ticket !== 'undefined' ? ticket : '')) ?>",
        autostart:  "<?= (typeof AUTOSTART  !== 'undefined' ? AUTOSTART  : '') ?>",   // '1' | ''
        debugServer:"<?= (typeof DEBUG      !== 'undefined' ? DEBUG      : '') ?>" === "1",
        serverLog:  `<?= (typeof SERVER_LOG !== 'undefined' ? SERVER_LOG : '') ?>`,
        wipe:       "<?= (typeof WIPE       !== 'undefined' ? WIPE       : '') ?>",   // '1' | ''
        pageTag:    "<?= (typeof PAGE_TAG   !== 'undefined' ? PAGE_TAG   : '') ?>" // etiqueta para prefixo nos logs ex.: 'LOGIN' | 'RGPD' | 'MAIN'
      };

      // Flags calculadas no cliente
      SV.noRedirect = /[?&]noredirect=1\b/i.test(location.search);

      const CANON_SELF = (() => {
        const fromSv = (SV.canonUrl || "").trim();
        if (fromSv) return fromSv;
        try { const stored = localStorage.getItem("appCanonicalUrl"); if (stored) return stored; } catch(_){}
        return location.origin + location.pathname;
      })();

      SV.canonSelf = CANON_SELF;
      window.CANON_SELF = CANON_SELF;

      // Persistir o que faz sentido (o /exec), não o userCodeAppPanel
      try { localStorage.setItem("appCanonicalUrl", CANON_SELF); } catch(_) {}

      // Expor de forma limpa
      window.__SERVER_VARS = Object.freeze(SV);

      // Ponte mínima (se quiser eliminar depois, pode)
      window.CANON_URL      = SV.canonUrl;
      window.SESSION_TICKET = SV.ticket;
      window.SERVER_LOG     = SV.serverLog;

      // --- Stubs anti-erro: garantem que log/dbg existem MESMO antes do logger carregar
      window.log = window.log || function(){ try{ console.log.apply(console, arguments); }catch(_){} };
      window.dbg = window.dbg || function(){};
    })();
    </script>

	  <!-- Logger global único (consola apenas) - no head dos html e servido pela AuthCoreLib. Aponta para a implementação B pois tem de ser web App -->
    <script src="https://script.google.com/macros/s/AKfycbw7CwrEid8YLInikNcmpqz9l9GzGFU40zTLL5mrTokCHiSgXivy4WQK6TbekB18tQ59/exec"></script>
    
  </head>
  <body>
    <h2>Proteção de dados (RGPD)</h2>
    <div class="card">
      <p><b>REGULAMENTO DA ASSOCIAÇÃO DOS TITULARES DE DRHP DO PORTOBELO</b></p>
      <p><b>Artigo 9.º — Proteção de dados</b></p>
      <ol>
        <li>
          A Associação recolhe e trata dados pessoais dos associados
          estritamente necessários ao cumprimento dos seus fins, designadamente
          identificação, contactos e dados relativos às semanas detidas.
        </li>
        <li>
          A Associação compromete-se a adotar medidas técnicas e organizativas
          adequadas para a proteção desses dados.
        </li>
        <li>
          Os dados serão usados apenas para fins associativos, com respeito pelo
          RGPD e legislação nacional.
        </li>
        <li>
          Os associados têm direito a aceder, retificar e solicitar a eliminação
          dos seus dados, salvo os que sejam legalmente obrigatórios para o
          funcionamento da Associação.
        </li>
      </ol>
      <div id="rgpd-multi" style="display: none; margin: 12px 0"></div>
      <div id="rgpd-multi-actions" style="display: none; margin: 12px 0">
        <button id="rgpd-save" class="btn">Guardar</button>
      </div>
    </div>

    <script>
      (function () {

        /*
        const EMBED = (function(){
          // estamos dentro de um <iframe> (top !== self) e viemos do teu site/Sites
          if (window.top === window.self) return false;
          const ref = document.referrer || '';
          return /titulares-portobelo\.pt|sites\.google\.com/i.test(ref);
        })();
        */

        log(`RGPD page`);

        function detectEnv(){
          const IN_IFRAME = (function(){ try { return window.top !== window.self; } catch(_) { return true; } })();
          const AO = (location.ancestorOrigins && Array.from(location.ancestorOrigins)) || [];

          // Qualquer origem Apps Script wrapper
          const isAppsScript = (o) => /^(https:\/\/[-\w.]*script\.googleusercontent\.com|https:\/\/script\.google\.com)$/i.test(o);

          // Estamos “externamente embebidos” se houver PELO MENOS um ancestor que NÃO seja Apps Script
          const HAS_NON_APPS_ANCESTOR = AO.some(o => !isAppsScript(o));

          const EXTERNAL_EMBED = IN_IFRAME && HAS_NON_APPS_ANCESTOR;
          //return { IN_IFRAME, EXTERNAL_EMBED, AO };
          return { EXTERNAL_EMBED };
        }

        const WANT_DEBUG  = window.DEBUG;

        // ✅ EMBED robusto
        const { EXTERNAL_EMBED } = detectEnv();
        const EMBED = /\bembed=1\b/i.test(location.search) || EXTERNAL_EMBED;  // só é true em iframe EXTERNO

        let CANON  = (__SERVER_VARS.canonUrl || (function(){ try{return localStorage.getItem('appCanonicalUrl')}catch(_){return ''} })() || (location.origin + location.pathname));
        if (!CANON) {
          try { CANON = localStorage.getItem('appCanonicalUrl') || ''; } catch(_) {}
          if (!CANON) CANON = location.origin + location.pathname;
        }

        let TICKET = (__SERVER_VARS.ticket || (new URL(location.href).searchParams.get('ticket') || (function(){ try{return localStorage.getItem('sessTicket')}catch(_){return ''} })()));
        if (!TICKET) {
          // 1) tenta apanhar do URL (vindo do Main com ?ticket=…)
          try { TICKET = new URL(location.href).searchParams.get('ticket') || ''; } catch(_) {}
        }
        if (!TICKET) {
          // 2) último recurso: localStorage (só funciona se mesma origem)
          try { TICKET = localStorage.getItem('sessTicket') || ''; } catch(_) {}
        }


        log(`RGPD page ready; CANON=${CANON}; have TICKET=${!!TICKET}; EMBED=${EMBED}; EXTERNAL_EMBED=${EXTERNAL_EMBED}`);

        function spanChip(txt){
          return `<span style="display:inline-block;border:1px solid #e5e7eb;border-radius:999px;padding:2px 8px;background:#eef2ff;font-family:ui-monospace,monospace">${String(txt||"").replace(/</g,"&lt;").replace(/>/g,"&gt;")}</span>`;
        }

        // Helper de navegação igual ao do Login (mesma semântica)
        function goWithParams(params) {
          //const u = new URL(location.href); // base = a página atual
          const u = (window.__SERVER_VARS && window.__SERVER_VARS.canonUrl) || window.CANON_URL;
          Object.keys(params).forEach(k => {
            const v = params[k];
            if (v !== undefined && v !== null && v !== '') u.searchParams.set(k, String(v));
          });
          const where = u.toString();
          log("[RGPD] replace → " + where);
          location.replace(where);
        }

        function renderMulti(rows){
          log("[RGPD/multi] entrada");
          try { log("[RGPD/multi] rows=" + JSON.stringify(rows)); } catch(_){}
          if (!rows || !rows.length){
            log("[RGPD/multi] nenhuma linha para este utilizador");
            const box = document.getElementById('rgpd-multi');
            box.style.display = '';
            box.innerHTML = `
              <div class="card">
                <div class="muted">Não há linhas para gerir o RGPD neste e-mail.</div>
                <div style="margin-top:8px">
                  <button id="rgpd-back">Voltar</button>
                </div>
              </div>`;
            document.getElementById('rgpd-back')?.addEventListener('click', () => {
              const BASE = (window.CANON_SELF || CANON_URL);
              const u = new URL(BASE);
              if (TICKET) u.searchParams.set("ticket", TICKET);
              if (WANT_DEBUG)    u.searchParams.set("debug", "1");
              u.searchParams.set("ts", Date.now());
              location.replace(u.toString());
            });
            return;
          }

          log("[RGPD/multi] criar html");
          // constroi cards com checkboxes
          const html = rows.map(r => `
            <div class="card" style="border:1px solid #e5e7eb;border-radius:10px;padding:10px;margin:8px 0">
              <label style="display:flex;gap:10px;align-items:center;cursor:pointer">
                <input type="checkbox" data-row="${r.row}" ${r.rgpd ? "checked":""}>
                <div>
                  <div><b>Semana(s)</b> ${spanChip(r.semanas)}</div>
                  <div class="muted small rgpd-label">RGPD: ${r.rgpd ? "Aceite" : "Rejeitado"}</div>
                </div>
              </label>
            </div>
          `).join("");

          const box = document.getElementById('rgpd-multi');
          box.innerHTML = html;
          box.style.display = '';

          // Atualiza rótulo “RGPD: …” em tempo real
          box.querySelectorAll('input[type="checkbox"][data-row]').forEach(cb => {
            const row = +cb.getAttribute('data-row');
            const lab = cb.closest('.card')?.querySelector('.rgpd-label');
            const update = () => {
              const on = !!cb.checked;
              if (lab) lab.textContent = 'RGPD: ' + (on ? 'Aceite' : 'Rejeitado');
              log(`[RGPD/multi] toggle row=${row} → ${on ? 'Aceite' : 'Rejeitado'}`);
            };
            cb.addEventListener('change', update);
          });

          const actions = document.getElementById('rgpd-multi-actions');
          actions.style.display = '';

          document.getElementById('rgpd-save').addEventListener("click",  function(ev){
            ev.preventDefault();
            log("[RGPD/multi] save click");

            const accepted = Array.from(document.querySelectorAll('#rgpd-multi input[type="checkbox"][data-row]'))
              .filter(b => b.checked).map(b => +b.getAttribute('data-row'));

            log("[RGPD/multi] accepted rows = [" + accepted.join(",") + "]");

            // Monta já o destino pós-RGPD (para usar no sucesso e no watchdog)
            const u = new URL(window.CANON_SELF || CANON, location.href);
            // força o servidor a ir direto ao Main (ignora gates)
            //u.searchParams.set('go','main');
            // Constrói URL para a página-ponte no TOPO, passando as linhas aceites
            u.searchParams.set('action','postrgpd');

            if (TICKET) u.searchParams.set('ticket', TICKET);
            if (accepted.length) u.searchParams.set('rows', accepted.join(','));
            if (WANT_DEBUG)    u.searchParams.set("debug","1");
            if (EXTERNAL_EMBED) u.searchParams.set("embed","1"); // só para diagnóstico no server
            u.searchParams.set('from','rgpd-save');
            u.searchParams.set('ts', Date.now());

            const where = u.toString();
            log("[RGPD] replace → " + where);
            location.replace(where);
          });
        }

        log("about to call listRgpdRowsFor (host)"); //!
        // Chama o host para obter linhas; se vier vazio, a página da biblioteca fica no modo single padrão
        google.script.run
          .withSuccessHandler(renderMulti)
          .withFailureHandler(function(err){
            alert("Erro a carregar linhas: " + (err && err.message ? err.message : String(err)));
          })
          .listRgpdRowsFor(TICKET);
      })();
    </script>
  </body>
</html>
