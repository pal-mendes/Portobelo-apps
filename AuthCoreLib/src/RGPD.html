
<!-- RGPD.html (em AuthCoreLib) -->
<!doctype html>
<html>
  <head>
    <base target="_self" />
    <meta charset="utf-8" />
    <title>RGPD</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        max-width: 820px;
        margin: 18px auto;
        padding: 0 14px;
        line-height: 1.45;
      }
      .card {
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        padding: 14px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      button {
        padding: 8px 12px;
        border: 1px solid #999;
        border-radius: 8px;
        background: #fff;
        cursor: pointer;
      }
    </style>

    <script>
    /* PB Server Vars — 1.º <script> no <head> (sem efeitos colaterais) */
    (function () {
      // Defensivo: usar typeof para evitar ReferenceError no template
      var SV = {
        canonUrl:   "<?= (typeof CANON_URL  !== 'undefined' ? CANON_URL  : '') ?>",
        ticket:     "<?= (typeof TICKET     !== 'undefined' ? TICKET     : (typeof ticket !== 'undefined' ? ticket : '')) ?>",
        autostart:  "<?= (typeof AUTOSTART  !== 'undefined' ? AUTOSTART  : '') ?>",   // '1' | ''
        debugServer:"<?= (typeof DEBUG      !== 'undefined' ? DEBUG      : '') ?>" === "1",
        serverLog:  `<?= (typeof SERVER_LOG !== 'undefined' ? SERVER_LOG : '') ?>`,
        wipe:       "<?= (typeof WIPE       !== 'undefined' ? WIPE       : '') ?>",   // '1' | ''
        pageTag:    "<?= (typeof PAGE_TAG   !== 'undefined' ? PAGE_TAG   : '') ?>" // etiqueta para prefixo nos logs ex.: 'LOGIN' | 'RGPD' | 'MAIN'
      };

      // Flags calculadas no cliente
      SV.noRedirect = /[?&]noredirect=1\b/i.test(location.search);

      // Persistir canónico para navegações subsequentes
      try { localStorage.setItem("appCanonicalUrl", SV.canonUrl || (location.origin + location.pathname)); } catch(_) {}

      // Expor de forma limpa
      window.__SERVER_VARS = Object.freeze(SV);

      // Ponte mínima (se quiser eliminar depois, pode)
      window.CANON_URL      = SV.canonUrl;
      window.SESSION_TICKET = SV.ticket;
      window.SERVER_LOG     = SV.serverLog;

      // --- Stubs anti-erro: garantem que log/dbg existem MESMO antes do logger carregar
      window.log = window.log || function(){ try{ console.log.apply(console, arguments); }catch(_){} };
      window.dbg = window.dbg || function(){};
    })();
    </script>

	  <!-- Logger global único (consola apenas) - no head dos html e servido pela AuthCoreLib-->
    <script src="https://script.google.com/macros/s/AKfycbzmNPPHIp35lUmlbl-6P0AmXIXT8sQuoAcjXeDlxKEGfWI7-gg3ncppVe8gtZ8BOvuIrQ/exec"></script>
    
  </head>
  <body>
    <h2>Proteção de dados (RGPD)</h2>
    <div class="card">
      <p><b>REGULAMENTO DA ASSOCIAÇÃO DOS TITULARES DE DRHP DO PORTOBELO</b></p>
      <p><b>Artigo 9.º — Proteção de dados</b></p>
      <ol>
        <li>
          A Associação recolhe e trata dados pessoais dos associados
          estritamente necessários ao cumprimento dos seus fins, designadamente
          identificação, contactos e dados relativos às semanas detidas.
        </li>
        <li>
          A Associação compromete-se a adotar medidas técnicas e organizativas
          adequadas para a proteção desses dados.
        </li>
        <li>
          Os dados serão usados apenas para fins associativos, com respeito pelo
          RGPD e legislação nacional.
        </li>
        <li>
          Os associados têm direito a aceder, retificar e solicitar a eliminação
          dos seus dados, salvo os que sejam legalmente obrigatórios para o
          funcionamento da Associação.
        </li>
      </ol>
      <div id="rgpd-multi" style="display: none; margin: 12px 0"></div>
      <div id="rgpd-multi-actions" style="display: none; margin: 12px 0">
        <button id="rgpd-save" class="btn">Guardar</button>
      </div>
    </div>

    <script>
      (function () {

        /*
        const EMBED = (function(){
          // estamos dentro de um <iframe> (top !== self) e viemos do teu site/Sites
          if (window.top === window.self) return false;
          const ref = document.referrer || '';
          return /titulares-portobelo\.pt|sites\.google\.com/i.test(ref);
        })();
        */

        log(`RGPD page`);

        function detectEnv(){
          const IN_IFRAME = (function(){ try { return window.top !== window.self; } catch(_) { return true; } })();
          const AO = (location.ancestorOrigins && Array.from(location.ancestorOrigins)) || [];

          // Qualquer origem Apps Script wrapper
          const isAppsScript = (o) => /^(https:\/\/[-\w.]*script\.googleusercontent\.com|https:\/\/script\.google\.com)$/i.test(o);

          // Estamos “externamente embebidos” se houver PELO MENOS um ancestor que NÃO seja Apps Script
          const HAS_NON_APPS_ANCESTOR = AO.some(o => !isAppsScript(o));

          const EXTERNAL_EMBED = IN_IFRAME && HAS_NON_APPS_ANCESTOR;
          //return { IN_IFRAME, EXTERNAL_EMBED, AO };
          return { EXTERNAL_EMBED };
        }

        const WANT_DEBUG  = window.DEBUG;

        // ✅ EMBED robusto
        const { EXTERNAL_EMBED } = detectEnv();
        const EMBED = /\bembed=1\b/i.test(location.search) || EXTERNAL_EMBED;  // só é true em iframe EXTERNO

        let CANON  = (__SERVER_VARS.canonUrl || (function(){ try{return localStorage.getItem('appCanonicalUrl')}catch(_){return ''} })() || (location.origin + location.pathname));
        if (!CANON) {
          try { CANON = localStorage.getItem('appCanonicalUrl') || ''; } catch(_) {}
          if (!CANON) CANON = location.origin + location.pathname;
        }

        let TICKET = (__SERVER_VARS.ticket || (new URL(location.href).searchParams.get('ticket') || (function(){ try{return localStorage.getItem('sessTicket')}catch(_){return ''} })()));
        if (!TICKET) {
          // 1) tenta apanhar do URL (vindo do Main com ?ticket=…)
          try { TICKET = new URL(location.href).searchParams.get('ticket') || ''; } catch(_) {}
        }
        if (!TICKET) {
          // 2) último recurso: localStorage (só funciona se mesma origem)
          try { TICKET = localStorage.getItem('sessTicket') || ''; } catch(_) {}
        }


        log(`RGPD page ready; CANON=${CANON}; have TICKET=${!!TICKET}; EMBED=${EMBED}; EXTERNAL_EMBED=${EXTERNAL_EMBED}`);

        function spanChip(txt){
          return `<span style="display:inline-block;border:1px solid #e5e7eb;border-radius:999px;padding:2px 8px;background:#eef2ff;font-family:ui-monospace,monospace">${String(txt||"").replace(/</g,"&lt;").replace(/>/g,"&gt;")}</span>`;
        }

        function renderMulti(rows){
          log("[RGPD/multi] entrada");
          try { log("[RGPD/multi] rows=" + JSON.stringify(rows)); } catch(_){}
          if (!rows || !rows.length){
            log("[RGPD/multi] nenhuma linha para este utilizador");
            const box = document.getElementById('rgpd-multi');
            box.style.display = '';
            box.innerHTML = `
              <div class="card">
                <div class="muted">Não há linhas para gerir o RGPD neste e-mail.</div>
                <div style="margin-top:8px">
                  <button id="rgpd-back">Voltar</button>
                </div>
              </div>`;
            document.getElementById('rgpd-back')?.addEventListener('click', () => {
              const u = new URL(CANON);
              if (TICKET) u.searchParams.set("ticket", TICKET);
              if (WANT_DEBUG)    u.searchParams.set("debug", "1");
              u.searchParams.set("ts", Date.now());
              location.replace(u.toString());
            });
            return;
          }

          log("[RGPD/multi] criar html");
          // constroi cards com checkboxes
          const html = rows.map(r => `
            <div class="card" style="border:1px solid #e5e7eb;border-radius:10px;padding:10px;margin:8px 0">
              <label style="display:flex;gap:10px;align-items:center;cursor:pointer">
                <input type="checkbox" data-row="${r.row}" ${r.rgpd ? "checked":""}>
                <div>
                  <div><b>Semana(s)</b> ${spanChip(r.semanas)}</div>
                  <div class="muted small rgpd-label">RGPD: ${r.rgpd ? "Aceite" : "Rejeitado"}</div>
                </div>
              </label>
            </div>
          `).join("");

          const box = document.getElementById('rgpd-multi');
          box.innerHTML = html;
          box.style.display = '';

          // Atualiza rótulo “RGPD: …” em tempo real
          box.querySelectorAll('input[type="checkbox"][data-row]').forEach(cb => {
            const row = +cb.getAttribute('data-row');
            const lab = cb.closest('.card')?.querySelector('.rgpd-label');
            const update = () => {
              const on = !!cb.checked;
              if (lab) lab.textContent = 'RGPD: ' + (on ? 'Aceite' : 'Rejeitado');
              log(`[RGPD/multi] toggle row=${row} → ${on ? 'Aceite' : 'Rejeitado'}`);
            };
            cb.addEventListener('change', update);
          });

          const actions = document.getElementById('rgpd-multi-actions');
          actions.style.display = '';

          document.getElementById('rgpd-save').onclick = function(ev){
          ev.preventDefault();
          log("[RGPD/multi] save click");

          const accepted = Array.from(document.querySelectorAll('#rgpd-multi input[type="checkbox"][data-row]'))
            .filter(b => b.checked).map(b => +b.getAttribute('data-row'));

          log("[RGPD/multi] accepted rows = [" + accepted.join(",") + "]");
          //dbg("[RGPD/multi] dbg");

          // Monta já o destino pós-RGPD (para usar no sucesso e no watchdog)
          const u = new URL(CANON);
          // força o servidor a ir direto ao Main (ignora gates)
          u.searchParams.set('go','main');
   
          if (TICKET) u.searchParams.set('ticket', TICKET);
          if (WANT_DEBUG)    u.searchParams.set("debug","1");
          if (EXTERNAL_EMBED) u.searchParams.set("embed","1"); // só para diagnóstico no server
          u.searchParams.set('from','rgpd-save');
          u.searchParams.set('ts', Date.now());
          const mainUrl = u.toString();

          // Navegação robusta: top→self (fora de embed) | self→top (embed externo)

          function navigateHard(where) {
            function goTop() {
              try { window.top.location = where; log("[RGPD] navigateHard: top.location"); return true; } catch(err) { log("ERR="+(err && err.message)); }
              try { window.top?.open(where, "_top"); log("[RGPD] navigateHard: top.open(_top)"); return true; } catch(err) { log("ERR="+(err && err.message)); }
              log("[RGPD/multi] goTop navigatedHard: return false");
              return false;
            }
            function goSelf() {
              try { location.replace(where); log("[RGPD] navigateHard: self.replace"); return true; } catch(err) { log("ERR="+(err && err.message)); }
              try { location.assign(where);  log("[RGPD] navigateHard: self.assign");  return true; } catch(err) { log("ERR="+(err && err.message)); }
              try { location.href = where;   log("[RGPD] navigateHard: self.href");    return true; } catch(err) { log("ERR="+(err && err.message)); }
              log("[RGPD/multi] goSelf navigatedHard: return false");
              return false;
            }
            // Fora de embed queremos sair da iframe do HTMLService → top primeiro
            return (EXTERNAL_EMBED ? (goSelf() || goTop()) : (goTop() || goSelf()));
          }

          log("[RGPD/multi] antes de watchdog"); //!
          // Watchdog: se o callback não disparar, força a navegação
          const wd = setTimeout(function(){
            log("[RGPD/multi] WARN: success handler não chamou em 15s → forçar navegação");
            navigateHard(mainUrl);
          }, 15000);

          log("[RGPD/multi] EXTERNAL_EMBED=" + EXTERNAL_EMBED); //!
          log("[RGPD/multi] antes de google.scrip.run .setRgpdRowsFor"); //!
          google.script.run
            .withSuccessHandler(function(res){
              clearTimeout(wd);
              log("[RGPD/multi] save ok " + JSON.stringify(res));
              // ⚠️ Tenta navegar de novo MESMO que o watchdog já tenha tentado.
              // Se a 1.ª tentativa foi bloqueada (gesto do utilizador vs. assíncrono),
              // esta costuma passar.
              navigateHard(mainUrl);
            })
            .withFailureHandler(function(err){
            clearTimeout(wd);
            const msg = err && err.message ? err.message : String(err);
            log("[RGPD/multi] save FAIL: " + msg);
            alert('Erro a guardar: ' + msg);
            })
            .setRgpdRowsFor(TICKET, accepted);
          };
        }

        log("about to call listRgpdRowsFor (host)"); //!
        // Chama o host para obter linhas; se vier vazio, a página da biblioteca fica no modo single padrão
        google.script.run
          .withSuccessHandler(renderMulti)
          .withFailureHandler(function(err){
            alert("Erro a carregar linhas: " + (err && err.message ? err.message : String(err)));
          })
          .listRgpdRowsFor(TICKET);
      })();
    </script>
  </body>
</html>
